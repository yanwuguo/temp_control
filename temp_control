

/* PicoDNA run with PCR and detecion.
 *  

Yanwu Guo
goavne@gmail.com

get logo bitmap: http://javl.github.io/image2cpp/

The SFE_TSL2561 library to read the AMS/TAOS TSL2561
light sensor. See more:


Hardware connections:
1. TSL2561  (address: 0x29, 0x39)
3V3 to 3.3V ~ 5v
GND to GND
SDA to A4 
SCL to A5

2. HC-06 X1

3. 480nm LED 

4. heating control

5. fan control

6. 100K Thermistor
A6
GND
5V

7. button

8. 128x64 OLED

*/

// Your sketch must #include this library, and the Wire library
// (Wire is a standard library included with Arduino):

#include <SFE_TSL2561.h> // light sensor
#include <Wire.h>
#include <SPI.h>
#include <U8glib.h> // OLED display

// Create an SFE_TSL2561 object, here called "light":

SFE_TSL2561 light;

// OLED Display
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE|U8G_I2C_OPT_DEV_0);  // I2C / TWI 

// Global variables:
 // 'picoDNA-128X64'
static unsigned char picoDNAlogo [] U8G_PROGMEM = {

   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x07, 0xf8, 0x03, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xfd, 0xff, 0xff, 0xff, 0x00, 0x00,
   0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x80, 0xff, 0xf6, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x03,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0x13, 0x00, 0xf7, 0x3c, 0xf8, 0x03, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00,
   0x00, 0xc0, 0x03, 0x00, 0x80, 0xfb, 0xc0, 0x03, 0x3f, 0xc0, 0x0f, 0x00,
   0xc0, 0x03, 0x00, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x80, 0xff, 0xc3, 0xc3,
   0x7f, 0xe0, 0x3f, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00,
   0x80, 0xff, 0xc3, 0xc3, 0xff, 0xf0, 0x7f, 0x00, 0xc0, 0x01, 0x02, 0x00,
   0x00, 0x00, 0x3c, 0x00, 0x80, 0xff, 0xc7, 0xe3, 0xfb, 0xf8, 0x7d, 0x00,
   0xc0, 0x00, 0x6f, 0x00, 0xf8, 0x01, 0x78, 0x00, 0x80, 0x87, 0xc7, 0xe3,
   0xf1, 0x78, 0xf8, 0x00, 0xc0, 0xc0, 0xff, 0x01, 0xfc, 0x07, 0xf0, 0x00,
   0x80, 0x87, 0xc7, 0xe3, 0x01, 0x78, 0xf0, 0x00, 0xc0, 0xe1, 0xff, 0x02,
   0xff, 0x0f, 0xe0, 0x01, 0x80, 0x83, 0xc7, 0xe3, 0x00, 0x38, 0xf0, 0x00,
   0xc0, 0xe1, 0xff, 0x05, 0xff, 0x1f, 0xc0, 0x03, 0x80, 0x87, 0xc7, 0xe3,
   0x01, 0x78, 0xf0, 0x00, 0xc0, 0xe0, 0xff, 0x87, 0xff, 0x3f, 0x00, 0x0f,
   0x80, 0x87, 0xc7, 0xe3, 0x61, 0x78, 0xf0, 0x00, 0xc0, 0xf1, 0xff, 0xc3,
   0xff, 0x3f, 0x00, 0x1f, 0x80, 0xcf, 0xc7, 0xe3, 0xf3, 0xf9, 0x78, 0x00,
   0xc0, 0xf9, 0xff, 0xc3, 0xff, 0x7f, 0x00, 0x1e, 0x80, 0xff, 0xc7, 0xe3,
   0xff, 0xf9, 0x7f, 0x00, 0x80, 0xf9, 0xff, 0xcf, 0xff, 0x7f, 0x00, 0x38,
   0x80, 0xff, 0xc3, 0xc3, 0xff, 0xf0, 0x3f, 0x00, 0xc0, 0xf1, 0xff, 0xcf,
   0xff, 0x7f, 0x00, 0x78, 0x80, 0xff, 0xc1, 0x83, 0x7f, 0xe0, 0x1f, 0x00,
   0xc0, 0xf1, 0xff, 0xc7, 0xff, 0x3f, 0x00, 0xf0, 0x80, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0xf1, 0xff, 0x87, 0xff, 0x1f, 0x00, 0xe0,
   0x81, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf1, 0xff, 0x87,
   0xff, 0x3f, 0x00, 0xc0, 0x83, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xc0, 0xe1, 0xff, 0x03, 0xff, 0x2f, 0x00, 0x80, 0x87, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0xc1, 0xff, 0x01, 0xff, 0x17, 0x00, 0x00,
   0x8f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x81, 0xff, 0x00,
   0xfe, 0x05, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xc0, 0x01, 0x7f, 0x00, 0x30, 0x03, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xc0, 0x03, 0x1e, 0x00, 0xf8, 0x01, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0x81, 0xff, 0x00, 0xfc, 0x07, 0x00, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc3, 0xff, 0x01,
   0xfe, 0x0f, 0x00, 0xd0, 0xc1, 0xff, 0x01, 0x1f, 0x78, 0x80, 0x0f, 0x00,
   0xc0, 0xc1, 0xff, 0x83, 0xff, 0x1f, 0x00, 0xd4, 0xc0, 0xff, 0x07, 0x1f,
   0x78, 0xc0, 0x0f, 0x00, 0xc0, 0xe1, 0xff, 0x87, 0xff, 0x3f, 0x00, 0xfc,
   0xc0, 0xff, 0x0f, 0x3f, 0x78, 0xc0, 0x1f, 0x00, 0xc0, 0xe1, 0xff, 0x87,
   0xff, 0x3f, 0x00, 0x76, 0xc0, 0xc7, 0x0f, 0x3f, 0x78, 0xe0, 0x1f, 0x00,
   0xc0, 0xf1, 0xff, 0xc7, 0xff, 0x3f, 0x00, 0x34, 0xc0, 0x03, 0x1f, 0x7f,
   0x78, 0xe0, 0x3f, 0x00, 0xc0, 0xe1, 0xff, 0xcf, 0xff, 0x3f, 0x00, 0x1f,
   0xc0, 0x03, 0x1e, 0xff, 0x78, 0xe0, 0x3d, 0x00, 0xc0, 0xf1, 0xff, 0xcf,
   0xff, 0x3f, 0xc0, 0x0f, 0xc0, 0x03, 0x1e, 0xff, 0x78, 0xf0, 0x3d, 0x00,
   0xc0, 0xf1, 0xff, 0x87, 0xff, 0x7f, 0x80, 0x07, 0xc0, 0x03, 0x1e, 0xff,
   0x79, 0xf0, 0x7c, 0x00, 0xc0, 0xf9, 0xff, 0x07, 0xff, 0x3f, 0x20, 0x01,
   0xc0, 0x03, 0x1e, 0xff, 0x7b, 0xf0, 0x78, 0x00, 0xc0, 0xf1, 0xff, 0x07,
   0xff, 0x1f, 0xf0, 0x01, 0xc0, 0x03, 0x1e, 0xef, 0x7f, 0xf8, 0x78, 0x00,
   0xc0, 0xf1, 0xff, 0x03, 0xff, 0x1f, 0xf0, 0x00, 0xc0, 0x03, 0x1e, 0xcf,
   0x7f, 0xf8, 0xff, 0x00, 0xc0, 0xe1, 0xff, 0x01, 0xfc, 0x0f, 0xf0, 0x00,
   0xc0, 0x03, 0x1e, 0x8f, 0x7f, 0xf8, 0xff, 0x00, 0xc0, 0xc1, 0xff, 0x00,
   0xf8, 0x07, 0x78, 0x00, 0xc0, 0x03, 0x1f, 0x8f, 0x7f, 0xfc, 0xff, 0x01,
   0xc0, 0x01, 0xff, 0x00, 0xcc, 0x03, 0x1e, 0x00, 0xc0, 0x83, 0x0f, 0x0f,
   0x7f, 0x7c, 0xf0, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x81, 0x0f, 0x00,
   0xc0, 0xff, 0x0f, 0x0f, 0x7f, 0x3c, 0xe0, 0x01, 0x40, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x07, 0x00, 0xc0, 0xff, 0x07, 0x0f, 0x7e, 0x3e, 0xe0, 0x03,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xc0, 0xff, 0x03, 0x0f,
   0x7c, 0x1e, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
   0x32, 0xc7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x04, 0x70, 0x79, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };

 // 'picoDNA-80x40'
static unsigned char picoDNAlogoSmall [] U8G_PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xf0, 0xff,
   0xff, 0x7f, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x30, 0x80, 0xed, 0x78,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0xe0, 0x01, 0xf0,
   0xc7, 0xf8, 0xf0, 0x03, 0x30, 0x00, 0x00, 0xc0, 0x01, 0xf0, 0xc7, 0xf8,
   0xf1, 0x03, 0x10, 0x3c, 0xc0, 0x03, 0x03, 0x70, 0xce, 0x9c, 0x19, 0x07,
   0x10, 0xfe, 0xe0, 0x07, 0x06, 0x70, 0xce, 0x1c, 0x18, 0x06, 0x30, 0xff,
   0xf1, 0x0f, 0x0c, 0x70, 0xce, 0x1c, 0x18, 0x06, 0x30, 0xff, 0xf8, 0x1f,
   0x38, 0xf0, 0xce, 0x9c, 0x3b, 0x03, 0xb0, 0xff, 0xf8, 0x1f, 0x30, 0xf0,
   0xcf, 0xfc, 0xfb, 0x03, 0x30, 0xff, 0xfb, 0x1f, 0x60, 0xf0, 0xc7, 0xf8,
   0xf0, 0x01, 0x30, 0xff, 0xf9, 0x1f, 0xc0, 0x70, 0x00, 0x00, 0x00, 0x00,
   0x30, 0xff, 0xf9, 0x1f, 0x80, 0x71, 0x00, 0x00, 0x00, 0x00, 0x30, 0xfe,
   0xf0, 0x07, 0x00, 0x77, 0x00, 0x00, 0x00, 0x00, 0x30, 0x7e, 0xe0, 0x07,
   0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x06,
   0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
   0x00, 0x00, 0x30, 0x7e, 0xe0, 0x07, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00,
   0x30, 0xfe, 0xf8, 0x0f, 0x90, 0xf0, 0x8f, 0xc3, 0xe0, 0x01, 0x30, 0xff,
   0xf9, 0x1f, 0xf0, 0xf0, 0x9f, 0xc7, 0xe0, 0x01, 0x30, 0xff, 0xf9, 0x1f,
   0x50, 0x30, 0x9c, 0xc7, 0xf0, 0x03, 0x30, 0xff, 0xfb, 0x1f, 0x38, 0x30,
   0x98, 0xcf, 0xf0, 0x03, 0x30, 0xff, 0xf9, 0x1f, 0x1c, 0x30, 0x98, 0xdf,
   0xb0, 0x03, 0x30, 0xff, 0xf1, 0x0f, 0x0e, 0x30, 0x98, 0xff, 0x38, 0x03,
   0x30, 0xff, 0xf0, 0x0f, 0x06, 0x30, 0x98, 0xfb, 0xf8, 0x07, 0x30, 0x7e,
   0xc0, 0x07, 0x03, 0x30, 0x9c, 0xfb, 0xfc, 0x0f, 0x30, 0x7c, 0x60, 0x83,
   0x01, 0x30, 0x9e, 0xf3, 0x1c, 0x0e, 0x00, 0x00, 0x00, 0xc0, 0x00, 0xf0,
   0x8f, 0xe3, 0x1c, 0x0e, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x82, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };


boolean gain;     // Gain setting, 0 = X1, 1 = X16;
unsigned int ms;  // Integration ("shutter") time in milliseconds
int ThermistorPin = A6; //A6
int btn1Pin = 6; //D6
int btn2Pin = 7;
int heatPin = 2;
int fanPin = 3;
int buzzerPin = 10;

int LED1Pin = 5;
int LED2Pin = 4;
//int LED3Pin; 
//int LED4Pin;
char BT_data = 0;            //Variable for storing received data

float CurrTemp;
int cycles = 0;

float lysisTemp = 98;
unsigned long lysisDuration = 3*60000;
float denatureTemp = 96 ;
float annealingTemp = 54;
float extensionTemp = 72;
unsigned long denatureDuration = 15000;
unsigned long annealingDuration = 15000;
unsigned long extensionDuration = 20000;
unsigned long lastExtensionDuration = 5*60000;

int NUM_CYCLES = 35;
  
//int CYCLE_left = NUM_CYCLES;

int LightSensor1 = 0x29;
int LightSensor2 = 0x39;
//int LightSensor3;
//int LightSensor4;

float startTemp;

float MAX_HEAT_INCREASE = 2.5;

float MAX_ALLOWED_TEMP = 100;

void lightSensor(int I2C_addr)
{
  // Initialize the Serial port:
  
  light.begin(I2C_addr);
  gain = 1;
  unsigned char time = 3;
  light.setTiming(gain,time,ms);
  light.setPowerUp(); 
  ms = 1000;
  light.manualStart();
  delay(ms);
  light.manualStop();

  unsigned int data0, data1;
  
  if (light.getData(data0,data1))
  {
    
    Serial.print("data0: ");
    Serial.print(data0);
    Serial.print(" data1: ");
    Serial.print(data1);
    double lux;    // Resulting lux value
    boolean good;  // True if neither sensor is saturated
    
    good = light.getLux(gain,ms,data0,data1,lux);  
    Serial.print(" lux: ");
    Serial.print(lux);
    if (good) Serial.println(" (good)"); else Serial.println(" (BAD)");
  }
  else
  {
    // getData() returned false because of an I2C error, inform the user.

    byte error = light.getError();
    printError(error);
  }
}

 

void printError(byte error)
  // If there's an I2C error, this function will
  // print out an explanation.
{
  Serial.print("I2C error: ");
  Serial.print(error,DEC);
  Serial.print(", ");
  
  switch(error)
  {
    case 0:
      Serial.println("success");
      break;
    case 1:
      Serial.println("data too long for transmit buffer");
      break;
    case 2:
      Serial.println("received NACK on address (disconnected?)");
      break;
    case 3:
      Serial.println("received NACK on data");
      break;
    case 4:
      Serial.println("other error");
      break;
    default:
      Serial.println("unknown error");
  }
}



int getLightData(int I2C_addr, int LED_num)
{
  //LED on
  digitalWrite(LED_num, HIGH);
  // Initialize the Serial port:
  
  light.begin(I2C_addr);
  gain = 1;
  unsigned char time = 3;
  light.setTiming(gain,time,ms);
  light.setPowerUp(); 
  ms = 2000;
  light.manualStart();
  delay(ms);
  light.manualStop();

  unsigned int data0, data1;
  
  if (light.getData(data0,data1))
  {   
    double lux;    // Resulting lux value
    boolean good;  // True if neither sensor is saturated
    
    good = light.getLux(gain,ms,data0,data1,lux);  
  }
  else
  {
    // getData() returned false because of an I2C error, inform the user.

    byte error = light.getError();
    printError(error);
  }
  digitalWrite(LED_num, LOW);

  return data0;
}


float getTc(int ThermistorPin){
  int Vo;
  float R1 = 10000;
  float logR2, R2, T, Tc, Tf;
  float c1 = 1.009249522e-03, c2 = 2.378405444e-04, c3 = 2.019202697e-07;

  Vo = analogRead(ThermistorPin);
  R2 = R1 * (1023.0 / (float)Vo - 1.0);
  logR2 = log(R2);
  T = (1.0 / (c1 + c2*logR2 + c3*logR2*logR2*logR2)); 
  Tc = T - 273.15;
  
  return Tc;
}



void runPCR(){
  //display "PCR started"
  u8g.firstPage();  
    do {
      drawPCRstart();
      drawTemp();
    } while( u8g.nextPage() );
    
  heatUpTo(lysisTemp + 5);
  holdAt(lysisTemp, lysisDuration);
  //display "PCR is running", "N cycles left"
  for (; cycles < NUM_CYCLES - 1; cycles++) {
 //    CYCLE_left = NUM_CYCLES - cycles;
//      //display "PCR started"
//      u8g.firstPage();  
//    do {
//      drawPCR(cycles);
//      drawTemp();
//    } while( u8g.nextPage() );
  
//    Serial.println("PCR is running");
//    Serial.print(CYCLE_left);
//    Serial.print("//");
//    Serial.println(NUM_CYCLES);
    coolDownTo(annealingTemp);
    holdAt(annealingTemp, annealingDuration);
    heatUpTo(extensionTemp + 2);
    holdAt(extensionTemp, extensionDuration);
    heatUpTo(denatureTemp + 3);
    holdAt(denatureTemp, denatureDuration);
    }
  heatUpTo(extensionTemp);
  holdAt(extensionTemp, lastExtensionDuration);
  coolDownTo(startTemp + 15);
  //display "PCR finished"
      u8g.firstPage();  
    do {
      drawFinshed();
    } while( u8g.nextPage() );

  Serial.println("DONE");

}






void runFastPCR(){
  //display "PCR started"
  u8g.firstPage();  
    do {
      drawPCRstart();
      drawTemp();
    } while( u8g.nextPage() );
    
  fastHeatUpTo(lysisTemp);
  holdAt(lysisTemp, lysisDuration);
  for (; cycles < NUM_CYCLES - 1; cycles++) {
    coolDownTo(annealingTemp);
    fastHeatUpTo(denatureTemp);
    }
  coolDownTo(extensionTemp);
  holdAt(extensionTemp, lastExtensionDuration);
  coolDownTo(startTemp + 15);
  //display "PCR finished"
      u8g.firstPage();  
    do {
      drawFinshed();
    } while( u8g.nextPage() );

  Serial.println("DONE");

}




boolean holdAt(float temp, long duration) {

  unsigned long startTime = millis();
  long timeElapsed = millis() - startTime;
  // keep track of how much time passed
  while (timeElapsed < duration) {
    float curTemp = getTc(ThermistorPin);
    
      if(curTemp < temp) {  
        // turn up the heat for 90ms if the temperature is cooler
        digitalWrite(heatPin, HIGH);
        delay(90);
        digitalWrite(heatPin, LOW);
         //display Temp
  u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
      } else if (curTemp > (temp + 0.2)) {
        // turn up the fan if the temp is too high
        // generally if temp is within 0.5degrees, don't use the fan
        // waiting for the temp to cool naturally seems to be more stable
        digitalWrite(fanPin, HIGH);
        delay(90);
        digitalWrite(fanPin, LOW);
          //display Temp
  u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
       
  }
  delay(200);
  timeElapsed = millis() - startTime; 
  }
   digitalWrite(fanPin, LOW);
   digitalWrite(heatPin, LOW);
  return true; 
}





void coolDownTo(float temperature){
  while (getTc(ThermistorPin) > temperature) {
         //display Temp
  u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    digitalWrite(fanPin, HIGH);
    digitalWrite(heatPin, LOW);
    }

    digitalWrite(fanPin, LOW);
    digitalWrite(heatPin, LOW);
}


boolean fastHeatUpTo(float temperature){
  while(getTc(ThermistorPin) < temperature) {
     u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    digitalWrite(fanPin, LOW);
    digitalWrite(heatPin, HIGH);
    }
    digitalWrite(fanPin, LOW);
    digitalWrite(heatPin, LOW);
}



boolean heatUpTo(float maxTemp){
  unsigned long startTime = millis(); 
  float prevTemp = getTc(ThermistorPin);
  float MAX_HEAT_INCREASE = 3;
  float MAX_ALLOWED_TEMP = 100;
  float curTemp = getTc(ThermistorPin);
//  if (curTemp < ROOM_TEMP) {
//   Serial.println("STARTING TMP TOO LOW");
//   Serial.println(prevTemp);
//   return false;
//  }
  int curIteration = 0;

  
  while (curTemp < maxTemp) {
    curIteration++;
    int pulseDuration = min(200, ((600*(maxTemp-curTemp))+80)); // as we approach desired temp, heat up slower
    digitalWrite(heatPin, HIGH);

     u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
    delay(pulseDuration);
    digitalWrite(heatPin, LOW);

     u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
    
    curTemp=getTc(ThermistorPin);
    if(curTemp >= maxTemp)
       break;
 
   if((maxTemp-curTemp) < 5 || curIteration % 15 == 0) {
     // as we approach desired temperature, wait a little bit longer between heat
     // cycles to make sure we don't overheat. It takes a while for heat to transfer
     // between resistors and heating block. As a sanity check, also do this every 20
     // iterations to make sure we're not overheating
      do  {
        prevTemp = curTemp;
        delay(350); 
        curTemp = getTc(ThermistorPin);
        
            u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
      }      while(curTemp > prevTemp);
    }

   if(curTemp >= maxTemp)
     break;
     
   if ((curIteration%2) == 0) {
    if(curTemp < (prevTemp-1.25)) {
      Serial.print("Temperature is not increasing... ");
      Serial.print(curTemp);
      Serial.print("   ");
      Serial.println(prevTemp);

          u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
      return false; 
    }
   } else {   
      prevTemp = curTemp;
   }
     
   while ((curTemp-prevTemp) >= MAX_HEAT_INCREASE) {
     prevTemp = curTemp;
     Serial.print("HEATING UP TOO FAST! ");
     delay(1000);
     curTemp = getTc(ThermistorPin);
         u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
     Serial.println(curTemp);
   }
   
   while(curTemp >= MAX_ALLOWED_TEMP) {
     delay(1000);
         u8g.firstPage();  
    do {
      drawPCR(cycles);
      drawTemp();
    } while( u8g.nextPage() );
    
     Serial.print("OVERHEATING");
     Serial.println(curTemp);
   }
   
  } 

   digitalWrite(fanPin, LOW);
    digitalWrite(heatPin, LOW);
    
  return true;
}








float runDetection(){
    //display "PCR started"
  u8g.firstPage();  
    do {
      drawDetectionstart();
    } while( u8g.nextPage() );
    
  int Sample1 = getLightData(LightSensor1, LED1Pin);
 // delay(1000);
  int Sample2 = getLightData(LightSensor2, LED2Pin);
//  int Sample3 = getLightData(LightSensor3, LED3Pin);
//  int Sample4 = getLightData(LightSensor4, LED4Pin);
  Serial.print("Sample1: ");          //Print Value inside data in Serial monitor
  Serial.print(Sample1);          //Print Value inside data in Serial monitor
  Serial.print("\n"); 
  Serial.print("Sample2: ");          //Print Value inside data in Serial monitor
  Serial.print(Sample2);          //Print Value inside data in Serial monitor
//  Serial.print("\n");   
//  Serial.print("Sample3: ");          //Print Value inside data in Serial monitor
//  Serial.print(Sample3);          //Print Value inside data in Serial monitor
//  Serial.print("\n"); 
//  Serial.print("Sample4: ");          //Print Value inside data in Serial monitor
//  Serial.print(Sample4);          //Print Value inside data in Serial monitor
//  Serial.print("\n");
    //display results"
      u8g.firstPage();  
    do {
      drawDetection(Sample1, Sample2);
    } while( u8g.nextPage() );          
}


// display function

void drawBegin() {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
    //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
      u8g.firstPage();  
  do {
    u8g.drawXBMP( 24, 0, 80, 40, picoDNAlogoSmall);
     //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
       u8g.drawStr( 0, 55, "PCR");
    u8g.drawStr( 75, 55, "Reader");

  } while( u8g.nextPage() );
  

}

void drawPCRstart() {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
  //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
      u8g.firstPage();  
  do {
    u8g.drawXBMP( 24, 0, 80, 40, picoDNAlogoSmall);
     //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
      u8g.drawStr( 0, 55, "PCR starts");
      //drawTemp();
  } while( u8g.nextPage() );
  
  }


void drawDetectionstart() {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
  //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
      u8g.firstPage();  
  do {
    u8g.drawXBMP( 24, 0, 80, 40, picoDNAlogoSmall);
     //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
      u8g.drawStr( 0, 55, "Detection starts....");
  } while( u8g.nextPage() );
  }

void drawPCR(int cycles) {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
  u8g.drawStr( 0, 20, "PCR is runing....");
  u8g.setPrintPos(0, 40); 
  u8g.print(cycles + 1);
  u8g.drawStr(20 , 40, "of");
  u8g.setPrintPos(40, 40); 
  u8g.print(NUM_CYCLES);
  u8g.drawStr(60 , 40, "cycles");

}


void drawFinshed() {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
  u8g.drawStr( 0, 20, "PCR is DONE");
  u8g.drawStr( 10, 45, "---------");

}

void drawTemp() {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
  u8g.drawStr( 0, 60, "T:");
  u8g.setPrintPos(15, 60); 
  u8g.print(getTc(ThermistorPin));
  u8g.drawStr( 55, 60, "oC");

}


void drawDetection(int Sample1, int Sample2) {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.setFont(u8g_font_unifont);
  //u8g.setFont(u8g_font_osb21);
  
  u8g.drawStr( 0, 20, "Sample1:");
  u8g.setPrintPos(65, 20); 
  u8g.print(Sample1);
  u8g.drawStr( 0, 50, "Sample2:");
  u8g.setPrintPos(65, 50); 
  u8g.print(Sample2);
  
}


void drawLogo() {
  // graphic commands to redraw the complete screen should be placed here  
  u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
}


// play sound


char notes[] = "cdfda ag cdfdg gf "; // a space represents a rest



void playTone()
{

    tone(buzzerPin, 2000);
    delay(100);
    tone(buzzerPin, 3000);
    delay(100);
   noTone(buzzerPin);
}


void playSound() 
{
const int songLength = 9;
int beats[] = {1,1,1,1,1,1,4,4,2,1,1,1,1,1,1,4,4,2};
int tempo = 113;
int i, duration;
for (i = 0; i < songLength; i++) // step through the song arrays
  {
    duration = beats[i] * tempo;  // length of note/rest in ms

    if (notes[i] == ' ')          // is this a rest? 
    {
      delay(duration);            // then pause for a moment
    }
    else                          // otherwise, play the note
    {
      tone(buzzerPin, frequency(notes[i]), duration);
      delay(duration);            // wait for tone to finish
    }
    delay(tempo/10);              // brief pause between notes
  }
}


int frequency(char note) 
{
  // This function takes a note character (a-g), and returns the
  // corresponding frequency in Hz for the tone() function.

  int i;
  const int numNotes = 8;  // number of notes we're storing

  // The following arrays hold the note characters and their
  // corresponding frequencies. The last "C" note is uppercase
  // to separate it from the first lowercase "c". If you want to
  // add more notes, you'll need to use unique characters.

  // For the "char" (character) type, we put single characters
  // in single quotes.

  char names[] = { 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'C' };
  int frequencies[] = {262, 294, 330, 349, 392, 440, 494, 523};

  // Now we'll search through the letters in the array, and if
  // we find it, we'll return the frequency for that note.

  for (i = 0; i < numNotes; i++)  // Step through the notes
  {
    if (names[i] == note)         // Is this the one?
    {
      return(frequencies[i]);     // Yes! Return the frequency
    }
  }
  return(0);  // We looked through everything and didn't find it,
              // but we still need to return a value, so return 0.
}



// setup data
void setup(){
  Serial.begin(9600);
  pinMode(fanPin, OUTPUT);
  pinMode(heatPin, OUTPUT);
  pinMode(LED1Pin, OUTPUT);
  pinMode(LED2Pin, OUTPUT);
  pinMode(btn1Pin, INPUT);
  pinMode(btn2Pin, INPUT);
  pinMode(buzzerPin, OUTPUT);
  digitalWrite(fanPin, LOW);
  digitalWrite(heatPin, LOW);
  digitalWrite(LED1Pin, LOW);
  digitalWrite(LED2Pin, LOW);
  digitalWrite(buzzerPin, LOW);
  //display setting
  u8g.setRot180();
  u8g.setColorIndex(1);
  //get R/T as starting temperature
  startTemp = getTc(ThermistorPin);
  //display "PicoDNA"
    u8g.firstPage();  
  do {
    drawBegin();
  } while( u8g.nextPage() );
  //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
      u8g.firstPage();  
  do {
    u8g.drawXBMP( 0, 0, 128, 64, picoDNAlogo);
     //u8g.drawBitmapP( 0, 0, 128, 64, picoDNAlogo);
  } while( u8g.nextPage() );
  delay(5000);
  
  playSound();
  
  u8g.firstPage();  
  do {
    drawBegin();
  } while( u8g.nextPage() );
  }

// run PCR or detection
void loop(){
  while(1){
    cycles=0;
    BT_data = Serial.read();   
    if ( BT_data == '1'){
      playTone();
      runPCR(); 
      playSound();
      }
    else if (BT_data == '2'){
      playTone();
      runDetection();
      }
    else if (BT_data == '3'){
      playTone();
      runFastPCR(); 
      playSound();
      }
    else if (digitalRead(btn1Pin) == HIGH){
      playTone();
      runFastPCR(); 
      playSound();
      }
    else if (digitalRead(btn2Pin) == HIGH){
      playTone();
      runDetection();
      }
    break;
    }
}
